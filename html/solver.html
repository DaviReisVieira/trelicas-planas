<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>solver API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>solver</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import math
import numpy as np
from funcoesTermosol import insert_constraints

class Point():
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __str__(self):
        return &#34;({}, {})&#34;.format(self.x, self.y)


class Node(Point):
    def __init__(self, x,y, id):
        super().__init__(x,y)
        self.id = id

    def __str__(self):
        return &#34;Node {} - ({}, {})&#34;.format(self.id, self.x, self.y)


class Element():
    def __init__(self, n1, n2, id, elasticity, area):
        self.n1 = n1
        self.n2 = n2
        self.id = id
        self.elasticity = elasticity
        self.area = area
        self.length = self.element_length()
        self.coords_difference = np.array([[self.n2.x - self.n1.x],[self.n2.y - self.n1.y]])
        self.stiff = (elasticity*area/self.length) * (self.coords_difference.dot(self.coords_difference.T)/(np.linalg.norm(self.coords_difference)**2))
        self.cos = (self.n2.x - self.n1.x)/self.length
        self.sin = (self.n2.y - self.n1.y)/self.length

    def element_length(self):
        &#34;&#34;&#34;
        Calculates the length of the element
        Input: None
        Output: Length of the element
        &#34;&#34;&#34;
        return math.sqrt((self.n1.x - self.n2.x)**2 + (self.n1.y - self.n2.y)**2)
    
    def connectivity_matrix(self, total_nodes):
        &#34;&#34;&#34;
        Calculates the connectivity matrix of the element
        Input: total_nodes
            - total_nodes: Total number of nodes
        Output: Connectivity matrix of the element
        &#34;&#34;&#34;
        connectivity = [0]*total_nodes
        connectivity[self.n1.id - 1] = -1
        connectivity[self.n2.id - 1] = 1
        return np.array(connectivity)

    def strain(self, u1, v1, u2, v2):
        &#34;&#34;&#34;
        Calculates the strain of the element
        Input: u1, v1, u2, v2
            - u1, v1: Displacements of the first node
            - u2, v2: Displacements of the second node
        Output: Strain of the element
        &#34;&#34;&#34;
        self.strain_value = np.array([-self.cos, -self.sin,self.cos, self.sin]).dot(np.array([[u1], [v1], [u2], [v2]]))/self.length

    def stiffness(self,total_nodes):
        &#34;&#34;&#34;
        Calculates the stiffness matrix of the element
        Input: total_nodes
            - total_nodes: Total number of nodes
        Output: Stiffness matrix of the element
        &#34;&#34;&#34;
        array = np.array([self.connectivity_matrix(total_nodes)])
        return np.kron(array.T.dot(array), self.stiff)
    
    def __str__(self):
        return &#34;Element: {} | {} | E={}Pa | A={}m²&#34;.format(self.n1, self.n2, self.elasticity, self.area)


class Solver():
    def __init__(self):
        print(&#39;------- Initializing solver -------\n&#39;)
        self.nodes = []
        self.elements = []
        self.constraints = []

    def add_node(self, x,y):
        &#34;&#34;&#34;
        Function to add a node to the list of nodes
        Input: x,y
            - x,y: coordinates of the node
        Output: None
        &#34;&#34;&#34;
        new_node = Node(x,y, len(self.nodes)+1)
        self.nodes.append(new_node)
        print(f&#39;- Added {new_node.__str__()}\n&#39;)

    def create_element(self, n1, n2, E, A):
        &#34;&#34;&#34;
        Function to create an element
        Input: n1, n2, E, A
            - n1, n2: nodes of the element
            - E: elasticity
            - A: area
        Output: None
        &#34;&#34;&#34;
        n1 = self.nodes[int(n1) - 1]
        n2 = self.nodes[int(n2) - 1]
        new_element = Element(n1, n2, len(self.elements)+1, E, A)
        self.elements.append(new_element)
        print(f&#39;- Added {new_element.__str__()}\n&#39;)

    def add_constraint(self,node,direction):
        &#34;&#34;&#34;
        Function to add a constraint to the list of constraints
        Input: node, direction
            - node: node to be constrained
            - direction: direction of the constraint
        Output: None
        &#34;&#34;&#34;
        node = int(node)
        direction = int(direction)
        self.constraints = insert_constraints(self.constraints, node, direction)
        print(f&#34;- Added constraint to node {node} in {&#39;x&#39; if direction == 1 else &#39;y&#39;} direction\n&#34;)

    def strain(self):
        &#34;&#34;&#34;
        Function to calculate the strain of the elements
        Input: None
        Output: None
        &#34;&#34;&#34;
        return np.array([el.strain_value for el in self.elements])

    def stiffness_sum(self):
        &#34;&#34;&#34;
        Function to calculate the stiffness matrix
        Input: None
        Output: None
        &#34;&#34;&#34;
        return sum([el.stiffness(len(self.nodes)) for el in self.elements])

    def get_nodes(self):
        &#34;&#34;&#34;
        Function to get the nodes
        Input: None
        Output: nodes
            - nodes: list of nodes
        &#34;&#34;&#34;
        return np.array([[n.x, n.y] for n in self.nodes]).T

    def gauss_seidel(self, K, F, n_iterations, tolerance):
        &#34;&#34;&#34;
        Function to solve the system of equations using the Gauss-Seidel method
        Input: K, F, n_iterations, tolerance
            - K: stiffness matrix
            - F: force vector
            - n_iterations: number of iterations
            - tolerance: tolerance of the method
        Output: u
            - u: displacements
        &#34;&#34;&#34;
        x = np.zeros_like(F, dtype=np.double)
        
        for k in range(n_iterations):
            x_old  = x.copy()
            for i in range(K.shape[0]):
                x[i] = (F[i] - np.dot(K[i, :i], x[:i]) - np.dot(K[i, (i + 1):], x_old[(i + 1):])) / K[i ,i]
                
            calc_tol = np.linalg.norm(x - x_old, ord=np.inf) / np.linalg.norm(x, ord=np.inf)
            if calc_tol &lt; tolerance:
                print(f&#34;Max number of iteration reached: {k} with Relative Difference {calc_tol}&#34;)
                return x
        
        print(f&#34;Max number of iteration reached: {k} with Relative Difference {calc_tol}&#34;)
            
        return x

    def solver(self, F, tolerance, max_iterations):
        &#34;&#34;&#34;
        Function to solve the system of equations
        Input: F, tolerance, max_iterations
            - F: force vector
            - tolerance: tolerance of the method
            - max_iterations: maximum number of iterations
        Output: reactions, strain, displacement
            - reactions: reactions of the nodes
            - strain: strain of the elements
            - displacement: displacement of the nodes
        &#34;&#34;&#34;
        stiffness_sum = self.stiffness_sum()

        cutted_lines_collumns = []

        for node, direction in self.constraints:
            cutted_line_collumn = 2*(int(node) - 1) + int(direction)//2
            
            F = np.delete(F, cutted_line_collumn, 0)
            stiffness_sum = np.delete(stiffness_sum, cutted_line_collumn, 0)
            stiffness_sum = np.delete(stiffness_sum, cutted_line_collumn, 1)
            
            cutted_lines_collumns.append(cutted_line_collumn)
        
        solved_values = self.gauss_seidel(stiffness_sum, F, max_iterations, tolerance)

        displacement = np.zeros((len(self.nodes)*2, 1))

        counter = 0
        for i in range(2*len(self.nodes)):
            if (i not in cutted_lines_collumns):
                displacement[i] = solved_values[counter]
                counter += 1

        reactions = self.stiffness_sum().dot(displacement)

        reactions[np.abs(reactions) &lt; tolerance] = 0

        reactions = np.around(reactions, decimals=2)

        final_reactions = []
        for node, direction in self.constraints:
            cutted_line_collumn = 2*(int(node) - 1) + int(direction)//2
            final_reactions.append([reactions[cutted_line_collumn][0]])
          
        final_reactions = np.array(final_reactions)
        final_reactions = np.flip(final_reactions, axis=0)
        final_reactions = np.flip(final_reactions, axis=1)

        for el in self.elements:
            ids = displacement[[2*(el.n1.id - 1), 2*(el.n1.id - 1) + 1,2*(el.n2.id - 1), 2*(el.n2.id - 1) + 1], 0]
            el.strain(*ids)

        return final_reactions, self.strain(), displacement</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="solver.Element"><code class="flex name class">
<span>class <span class="ident">Element</span></span>
<span>(</span><span>n1, n2, id, elasticity, area)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Element():
    def __init__(self, n1, n2, id, elasticity, area):
        self.n1 = n1
        self.n2 = n2
        self.id = id
        self.elasticity = elasticity
        self.area = area
        self.length = self.element_length()
        self.coords_difference = np.array([[self.n2.x - self.n1.x],[self.n2.y - self.n1.y]])
        self.stiff = (elasticity*area/self.length) * (self.coords_difference.dot(self.coords_difference.T)/(np.linalg.norm(self.coords_difference)**2))
        self.cos = (self.n2.x - self.n1.x)/self.length
        self.sin = (self.n2.y - self.n1.y)/self.length

    def element_length(self):
        &#34;&#34;&#34;
        Calculates the length of the element
        Input: None
        Output: Length of the element
        &#34;&#34;&#34;
        return math.sqrt((self.n1.x - self.n2.x)**2 + (self.n1.y - self.n2.y)**2)
    
    def connectivity_matrix(self, total_nodes):
        &#34;&#34;&#34;
        Calculates the connectivity matrix of the element
        Input: total_nodes
            - total_nodes: Total number of nodes
        Output: Connectivity matrix of the element
        &#34;&#34;&#34;
        connectivity = [0]*total_nodes
        connectivity[self.n1.id - 1] = -1
        connectivity[self.n2.id - 1] = 1
        return np.array(connectivity)

    def strain(self, u1, v1, u2, v2):
        &#34;&#34;&#34;
        Calculates the strain of the element
        Input: u1, v1, u2, v2
            - u1, v1: Displacements of the first node
            - u2, v2: Displacements of the second node
        Output: Strain of the element
        &#34;&#34;&#34;
        self.strain_value = np.array([-self.cos, -self.sin,self.cos, self.sin]).dot(np.array([[u1], [v1], [u2], [v2]]))/self.length

    def stiffness(self,total_nodes):
        &#34;&#34;&#34;
        Calculates the stiffness matrix of the element
        Input: total_nodes
            - total_nodes: Total number of nodes
        Output: Stiffness matrix of the element
        &#34;&#34;&#34;
        array = np.array([self.connectivity_matrix(total_nodes)])
        return np.kron(array.T.dot(array), self.stiff)
    
    def __str__(self):
        return &#34;Element: {} | {} | E={}Pa | A={}m²&#34;.format(self.n1, self.n2, self.elasticity, self.area)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="solver.Element.connectivity_matrix"><code class="name flex">
<span>def <span class="ident">connectivity_matrix</span></span>(<span>self, total_nodes)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the connectivity matrix of the element
Input: total_nodes
- total_nodes: Total number of nodes
Output: Connectivity matrix of the element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connectivity_matrix(self, total_nodes):
    &#34;&#34;&#34;
    Calculates the connectivity matrix of the element
    Input: total_nodes
        - total_nodes: Total number of nodes
    Output: Connectivity matrix of the element
    &#34;&#34;&#34;
    connectivity = [0]*total_nodes
    connectivity[self.n1.id - 1] = -1
    connectivity[self.n2.id - 1] = 1
    return np.array(connectivity)</code></pre>
</details>
</dd>
<dt id="solver.Element.element_length"><code class="name flex">
<span>def <span class="ident">element_length</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the length of the element
Input: None
Output: Length of the element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def element_length(self):
    &#34;&#34;&#34;
    Calculates the length of the element
    Input: None
    Output: Length of the element
    &#34;&#34;&#34;
    return math.sqrt((self.n1.x - self.n2.x)**2 + (self.n1.y - self.n2.y)**2)</code></pre>
</details>
</dd>
<dt id="solver.Element.stiffness"><code class="name flex">
<span>def <span class="ident">stiffness</span></span>(<span>self, total_nodes)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the stiffness matrix of the element
Input: total_nodes
- total_nodes: Total number of nodes
Output: Stiffness matrix of the element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stiffness(self,total_nodes):
    &#34;&#34;&#34;
    Calculates the stiffness matrix of the element
    Input: total_nodes
        - total_nodes: Total number of nodes
    Output: Stiffness matrix of the element
    &#34;&#34;&#34;
    array = np.array([self.connectivity_matrix(total_nodes)])
    return np.kron(array.T.dot(array), self.stiff)</code></pre>
</details>
</dd>
<dt id="solver.Element.strain"><code class="name flex">
<span>def <span class="ident">strain</span></span>(<span>self, u1, v1, u2, v2)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the strain of the element
Input: u1, v1, u2, v2
- u1, v1: Displacements of the first node
- u2, v2: Displacements of the second node
Output: Strain of the element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strain(self, u1, v1, u2, v2):
    &#34;&#34;&#34;
    Calculates the strain of the element
    Input: u1, v1, u2, v2
        - u1, v1: Displacements of the first node
        - u2, v2: Displacements of the second node
    Output: Strain of the element
    &#34;&#34;&#34;
    self.strain_value = np.array([-self.cos, -self.sin,self.cos, self.sin]).dot(np.array([[u1], [v1], [u2], [v2]]))/self.length</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="solver.Node"><code class="flex name class">
<span>class <span class="ident">Node</span></span>
<span>(</span><span>x, y, id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Node(Point):
    def __init__(self, x,y, id):
        super().__init__(x,y)
        self.id = id

    def __str__(self):
        return &#34;Node {} - ({}, {})&#34;.format(self.id, self.x, self.y)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="solver.Point" href="#solver.Point">Point</a></li>
</ul>
</dd>
<dt id="solver.Point"><code class="flex name class">
<span>class <span class="ident">Point</span></span>
<span>(</span><span>x, y)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Point():
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __str__(self):
        return &#34;({}, {})&#34;.format(self.x, self.y)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="solver.Node" href="#solver.Node">Node</a></li>
</ul>
</dd>
<dt id="solver.Solver"><code class="flex name class">
<span>class <span class="ident">Solver</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Solver():
    def __init__(self):
        print(&#39;------- Initializing solver -------\n&#39;)
        self.nodes = []
        self.elements = []
        self.constraints = []

    def add_node(self, x,y):
        &#34;&#34;&#34;
        Function to add a node to the list of nodes
        Input: x,y
            - x,y: coordinates of the node
        Output: None
        &#34;&#34;&#34;
        new_node = Node(x,y, len(self.nodes)+1)
        self.nodes.append(new_node)
        print(f&#39;- Added {new_node.__str__()}\n&#39;)

    def create_element(self, n1, n2, E, A):
        &#34;&#34;&#34;
        Function to create an element
        Input: n1, n2, E, A
            - n1, n2: nodes of the element
            - E: elasticity
            - A: area
        Output: None
        &#34;&#34;&#34;
        n1 = self.nodes[int(n1) - 1]
        n2 = self.nodes[int(n2) - 1]
        new_element = Element(n1, n2, len(self.elements)+1, E, A)
        self.elements.append(new_element)
        print(f&#39;- Added {new_element.__str__()}\n&#39;)

    def add_constraint(self,node,direction):
        &#34;&#34;&#34;
        Function to add a constraint to the list of constraints
        Input: node, direction
            - node: node to be constrained
            - direction: direction of the constraint
        Output: None
        &#34;&#34;&#34;
        node = int(node)
        direction = int(direction)
        self.constraints = insert_constraints(self.constraints, node, direction)
        print(f&#34;- Added constraint to node {node} in {&#39;x&#39; if direction == 1 else &#39;y&#39;} direction\n&#34;)

    def strain(self):
        &#34;&#34;&#34;
        Function to calculate the strain of the elements
        Input: None
        Output: None
        &#34;&#34;&#34;
        return np.array([el.strain_value for el in self.elements])

    def stiffness_sum(self):
        &#34;&#34;&#34;
        Function to calculate the stiffness matrix
        Input: None
        Output: None
        &#34;&#34;&#34;
        return sum([el.stiffness(len(self.nodes)) for el in self.elements])

    def get_nodes(self):
        &#34;&#34;&#34;
        Function to get the nodes
        Input: None
        Output: nodes
            - nodes: list of nodes
        &#34;&#34;&#34;
        return np.array([[n.x, n.y] for n in self.nodes]).T

    def gauss_seidel(self, K, F, n_iterations, tolerance):
        &#34;&#34;&#34;
        Function to solve the system of equations using the Gauss-Seidel method
        Input: K, F, n_iterations, tolerance
            - K: stiffness matrix
            - F: force vector
            - n_iterations: number of iterations
            - tolerance: tolerance of the method
        Output: u
            - u: displacements
        &#34;&#34;&#34;
        x = np.zeros_like(F, dtype=np.double)
        
        for k in range(n_iterations):
            x_old  = x.copy()
            for i in range(K.shape[0]):
                x[i] = (F[i] - np.dot(K[i, :i], x[:i]) - np.dot(K[i, (i + 1):], x_old[(i + 1):])) / K[i ,i]
                
            calc_tol = np.linalg.norm(x - x_old, ord=np.inf) / np.linalg.norm(x, ord=np.inf)
            if calc_tol &lt; tolerance:
                print(f&#34;Max number of iteration reached: {k} with Relative Difference {calc_tol}&#34;)
                return x
        
        print(f&#34;Max number of iteration reached: {k} with Relative Difference {calc_tol}&#34;)
            
        return x

    def solver(self, F, tolerance, max_iterations):
        &#34;&#34;&#34;
        Function to solve the system of equations
        Input: F, tolerance, max_iterations
            - F: force vector
            - tolerance: tolerance of the method
            - max_iterations: maximum number of iterations
        Output: reactions, strain, displacement
            - reactions: reactions of the nodes
            - strain: strain of the elements
            - displacement: displacement of the nodes
        &#34;&#34;&#34;
        stiffness_sum = self.stiffness_sum()

        cutted_lines_collumns = []

        for node, direction in self.constraints:
            cutted_line_collumn = 2*(int(node) - 1) + int(direction)//2
            
            F = np.delete(F, cutted_line_collumn, 0)
            stiffness_sum = np.delete(stiffness_sum, cutted_line_collumn, 0)
            stiffness_sum = np.delete(stiffness_sum, cutted_line_collumn, 1)
            
            cutted_lines_collumns.append(cutted_line_collumn)
        
        solved_values = self.gauss_seidel(stiffness_sum, F, max_iterations, tolerance)

        displacement = np.zeros((len(self.nodes)*2, 1))

        counter = 0
        for i in range(2*len(self.nodes)):
            if (i not in cutted_lines_collumns):
                displacement[i] = solved_values[counter]
                counter += 1

        reactions = self.stiffness_sum().dot(displacement)

        reactions[np.abs(reactions) &lt; tolerance] = 0

        reactions = np.around(reactions, decimals=2)

        final_reactions = []
        for node, direction in self.constraints:
            cutted_line_collumn = 2*(int(node) - 1) + int(direction)//2
            final_reactions.append([reactions[cutted_line_collumn][0]])
          
        final_reactions = np.array(final_reactions)
        final_reactions = np.flip(final_reactions, axis=0)
        final_reactions = np.flip(final_reactions, axis=1)

        for el in self.elements:
            ids = displacement[[2*(el.n1.id - 1), 2*(el.n1.id - 1) + 1,2*(el.n2.id - 1), 2*(el.n2.id - 1) + 1], 0]
            el.strain(*ids)

        return final_reactions, self.strain(), displacement</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="solver.Solver.add_constraint"><code class="name flex">
<span>def <span class="ident">add_constraint</span></span>(<span>self, node, direction)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to add a constraint to the list of constraints
Input: node, direction
- node: node to be constrained
- direction: direction of the constraint
Output: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_constraint(self,node,direction):
    &#34;&#34;&#34;
    Function to add a constraint to the list of constraints
    Input: node, direction
        - node: node to be constrained
        - direction: direction of the constraint
    Output: None
    &#34;&#34;&#34;
    node = int(node)
    direction = int(direction)
    self.constraints = insert_constraints(self.constraints, node, direction)
    print(f&#34;- Added constraint to node {node} in {&#39;x&#39; if direction == 1 else &#39;y&#39;} direction\n&#34;)</code></pre>
</details>
</dd>
<dt id="solver.Solver.add_node"><code class="name flex">
<span>def <span class="ident">add_node</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to add a node to the list of nodes
Input: x,y
- x,y: coordinates of the node
Output: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_node(self, x,y):
    &#34;&#34;&#34;
    Function to add a node to the list of nodes
    Input: x,y
        - x,y: coordinates of the node
    Output: None
    &#34;&#34;&#34;
    new_node = Node(x,y, len(self.nodes)+1)
    self.nodes.append(new_node)
    print(f&#39;- Added {new_node.__str__()}\n&#39;)</code></pre>
</details>
</dd>
<dt id="solver.Solver.create_element"><code class="name flex">
<span>def <span class="ident">create_element</span></span>(<span>self, n1, n2, E, A)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to create an element
Input: n1, n2, E, A
- n1, n2: nodes of the element
- E: elasticity
- A: area
Output: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_element(self, n1, n2, E, A):
    &#34;&#34;&#34;
    Function to create an element
    Input: n1, n2, E, A
        - n1, n2: nodes of the element
        - E: elasticity
        - A: area
    Output: None
    &#34;&#34;&#34;
    n1 = self.nodes[int(n1) - 1]
    n2 = self.nodes[int(n2) - 1]
    new_element = Element(n1, n2, len(self.elements)+1, E, A)
    self.elements.append(new_element)
    print(f&#39;- Added {new_element.__str__()}\n&#39;)</code></pre>
</details>
</dd>
<dt id="solver.Solver.gauss_seidel"><code class="name flex">
<span>def <span class="ident">gauss_seidel</span></span>(<span>self, K, F, n_iterations, tolerance)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to solve the system of equations using the Gauss-Seidel method
Input: K, F, n_iterations, tolerance
- K: stiffness matrix
- F: force vector
- n_iterations: number of iterations
- tolerance: tolerance of the method
Output: u
- u: displacements</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gauss_seidel(self, K, F, n_iterations, tolerance):
    &#34;&#34;&#34;
    Function to solve the system of equations using the Gauss-Seidel method
    Input: K, F, n_iterations, tolerance
        - K: stiffness matrix
        - F: force vector
        - n_iterations: number of iterations
        - tolerance: tolerance of the method
    Output: u
        - u: displacements
    &#34;&#34;&#34;
    x = np.zeros_like(F, dtype=np.double)
    
    for k in range(n_iterations):
        x_old  = x.copy()
        for i in range(K.shape[0]):
            x[i] = (F[i] - np.dot(K[i, :i], x[:i]) - np.dot(K[i, (i + 1):], x_old[(i + 1):])) / K[i ,i]
            
        calc_tol = np.linalg.norm(x - x_old, ord=np.inf) / np.linalg.norm(x, ord=np.inf)
        if calc_tol &lt; tolerance:
            print(f&#34;Max number of iteration reached: {k} with Relative Difference {calc_tol}&#34;)
            return x
    
    print(f&#34;Max number of iteration reached: {k} with Relative Difference {calc_tol}&#34;)
        
    return x</code></pre>
</details>
</dd>
<dt id="solver.Solver.get_nodes"><code class="name flex">
<span>def <span class="ident">get_nodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to get the nodes
Input: None
Output: nodes
- nodes: list of nodes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nodes(self):
    &#34;&#34;&#34;
    Function to get the nodes
    Input: None
    Output: nodes
        - nodes: list of nodes
    &#34;&#34;&#34;
    return np.array([[n.x, n.y] for n in self.nodes]).T</code></pre>
</details>
</dd>
<dt id="solver.Solver.solver"><code class="name flex">
<span>def <span class="ident">solver</span></span>(<span>self, F, tolerance, max_iterations)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to solve the system of equations
Input: F, tolerance, max_iterations
- F: force vector
- tolerance: tolerance of the method
- max_iterations: maximum number of iterations
Output: reactions, strain, displacement
- reactions: reactions of the nodes
- strain: strain of the elements
- displacement: displacement of the nodes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solver(self, F, tolerance, max_iterations):
    &#34;&#34;&#34;
    Function to solve the system of equations
    Input: F, tolerance, max_iterations
        - F: force vector
        - tolerance: tolerance of the method
        - max_iterations: maximum number of iterations
    Output: reactions, strain, displacement
        - reactions: reactions of the nodes
        - strain: strain of the elements
        - displacement: displacement of the nodes
    &#34;&#34;&#34;
    stiffness_sum = self.stiffness_sum()

    cutted_lines_collumns = []

    for node, direction in self.constraints:
        cutted_line_collumn = 2*(int(node) - 1) + int(direction)//2
        
        F = np.delete(F, cutted_line_collumn, 0)
        stiffness_sum = np.delete(stiffness_sum, cutted_line_collumn, 0)
        stiffness_sum = np.delete(stiffness_sum, cutted_line_collumn, 1)
        
        cutted_lines_collumns.append(cutted_line_collumn)
    
    solved_values = self.gauss_seidel(stiffness_sum, F, max_iterations, tolerance)

    displacement = np.zeros((len(self.nodes)*2, 1))

    counter = 0
    for i in range(2*len(self.nodes)):
        if (i not in cutted_lines_collumns):
            displacement[i] = solved_values[counter]
            counter += 1

    reactions = self.stiffness_sum().dot(displacement)

    reactions[np.abs(reactions) &lt; tolerance] = 0

    reactions = np.around(reactions, decimals=2)

    final_reactions = []
    for node, direction in self.constraints:
        cutted_line_collumn = 2*(int(node) - 1) + int(direction)//2
        final_reactions.append([reactions[cutted_line_collumn][0]])
      
    final_reactions = np.array(final_reactions)
    final_reactions = np.flip(final_reactions, axis=0)
    final_reactions = np.flip(final_reactions, axis=1)

    for el in self.elements:
        ids = displacement[[2*(el.n1.id - 1), 2*(el.n1.id - 1) + 1,2*(el.n2.id - 1), 2*(el.n2.id - 1) + 1], 0]
        el.strain(*ids)

    return final_reactions, self.strain(), displacement</code></pre>
</details>
</dd>
<dt id="solver.Solver.stiffness_sum"><code class="name flex">
<span>def <span class="ident">stiffness_sum</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to calculate the stiffness matrix
Input: None
Output: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stiffness_sum(self):
    &#34;&#34;&#34;
    Function to calculate the stiffness matrix
    Input: None
    Output: None
    &#34;&#34;&#34;
    return sum([el.stiffness(len(self.nodes)) for el in self.elements])</code></pre>
</details>
</dd>
<dt id="solver.Solver.strain"><code class="name flex">
<span>def <span class="ident">strain</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to calculate the strain of the elements
Input: None
Output: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strain(self):
    &#34;&#34;&#34;
    Function to calculate the strain of the elements
    Input: None
    Output: None
    &#34;&#34;&#34;
    return np.array([el.strain_value for el in self.elements])</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="solver.Element" href="#solver.Element">Element</a></code></h4>
<ul class="">
<li><code><a title="solver.Element.connectivity_matrix" href="#solver.Element.connectivity_matrix">connectivity_matrix</a></code></li>
<li><code><a title="solver.Element.element_length" href="#solver.Element.element_length">element_length</a></code></li>
<li><code><a title="solver.Element.stiffness" href="#solver.Element.stiffness">stiffness</a></code></li>
<li><code><a title="solver.Element.strain" href="#solver.Element.strain">strain</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="solver.Node" href="#solver.Node">Node</a></code></h4>
</li>
<li>
<h4><code><a title="solver.Point" href="#solver.Point">Point</a></code></h4>
</li>
<li>
<h4><code><a title="solver.Solver" href="#solver.Solver">Solver</a></code></h4>
<ul class="two-column">
<li><code><a title="solver.Solver.add_constraint" href="#solver.Solver.add_constraint">add_constraint</a></code></li>
<li><code><a title="solver.Solver.add_node" href="#solver.Solver.add_node">add_node</a></code></li>
<li><code><a title="solver.Solver.create_element" href="#solver.Solver.create_element">create_element</a></code></li>
<li><code><a title="solver.Solver.gauss_seidel" href="#solver.Solver.gauss_seidel">gauss_seidel</a></code></li>
<li><code><a title="solver.Solver.get_nodes" href="#solver.Solver.get_nodes">get_nodes</a></code></li>
<li><code><a title="solver.Solver.solver" href="#solver.Solver.solver">solver</a></code></li>
<li><code><a title="solver.Solver.stiffness_sum" href="#solver.Solver.stiffness_sum">stiffness_sum</a></code></li>
<li><code><a title="solver.Solver.strain" href="#solver.Solver.strain">strain</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>